% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aaa-classes-output.R, R/aaa-generics-output.R
\docType{class}
\name{hdpSampleChain-class}
\alias{as.list,hdpSampleChain-method}
\alias{clust_categ_counts}
\alias{clust_categ_counts,hdpSampleChain-method}
\alias{clust_dp_counts}
\alias{clust_dp_counts,hdpSampleChain-method}
\alias{comp_categ_counts,hdpSampleChain-method}
\alias{comp_categ_distn,hdpSampleChain-method}
\alias{comp_cos_merge,hdpSampleChain-method}
\alias{comp_dp_counts,hdpSampleChain-method}
\alias{comp_dp_distn,hdpSampleChain-method}
\alias{cp_values}
\alias{cp_values,hdpSampleChain-method}
\alias{final_hdpState}
\alias{final_hdpState,hdpSampleChain-method}
\alias{hdpSampleChain-class}
\alias{hdp_settings}
\alias{hdp_settings,hdpSampleChain-method}
\alias{lik}
\alias{lik,hdpSampleChain-method}
\alias{numcluster}
\alias{numcluster,hdpSampleChain-method}
\alias{numcomp,hdpSampleChain-method}
\alias{prop.ex,hdpSampleChain-method}
\alias{sampling_seed}
\alias{sampling_seed,hdpSampleChain-method}
\title{hdpSampleChain class for posterior samples off one MCMC chain}
\usage{
\S4method{as.list}{hdpSampleChain}(x, ...)

\S4method{sampling_seed}{hdpSampleChain}(x, ...)

\S4method{hdp_settings}{hdpSampleChain}(x, ...)

\S4method{final_hdpState}{hdpSampleChain}(x, ...)

\S4method{lik}{hdpSampleChain}(x, ...)

\S4method{numcluster}{hdpSampleChain}(x, ...)

\S4method{cp_values}{hdpSampleChain}(x, ...)

\S4method{clust_categ_counts}{hdpSampleChain}(x, ...)

\S4method{clust_dp_counts}{hdpSampleChain}(x, ...)

\S4method{numcomp}{hdpSampleChain}(x)

\S4method{prop.ex}{hdpSampleChain}(x)

\S4method{comp_cos_merge}{hdpSampleChain}(x)

\S4method{comp_categ_counts}{hdpSampleChain}(x)

\S4method{comp_dp_counts}{hdpSampleChain}(x)

\S4method{comp_categ_distn}{hdpSampleChain}(x)

\S4method{comp_dp_distn}{hdpSampleChain}(x)
}
\arguments{
\item{x}{Object of class hdpSampleChain}

\item{...}{unused}
}
\description{
hdpSampleChain class for posterior samples off one MCMC chain
}
\section{Methods (by generic)}{
\itemize{
\item \code{as.list}: Convert to list class

\item \code{sampling_seed}: Get random seed used by \code{hdp_posterior}

\item \code{hdp_settings}: Get settings of posterior sampling chain

\item \code{final_hdpState}: Get hdpState object from the end of the posterior sampling chain

\item \code{lik}: Get likelihood of data given model over all iterations

\item \code{numcluster}: Get the number of clusters for each posterior sample

\item \code{cp_values}: Get matrix of concentration parameter values for each posterior sample

\item \code{clust_categ_counts}: Get category vs cluster counts for each posterior sample

\item \code{clust_dp_counts}: Get dp node vs cluster counts for each posterior sample

\item \code{numcomp}: Get number of extracted components for hdpSampleChain

\item \code{prop.ex}: Get proportion of dataset explained (on average) for hdpSampleChain

\item \code{comp_cos_merge}: Get cos.merge setting for hdpSampleChain

\item \code{comp_categ_counts}: Get sample vs category counts for each component

\item \code{comp_dp_counts}: Get sample vs component counts for each DP

\item \code{comp_categ_distn}: Get mean distribution over data categories for each component

\item \code{comp_dp_distn}: Get mean distribution over components for each DP
}}
\section{Slots}{

\describe{
\item{\code{seed}}{Random seed used by \code{hdp_posterior}}

\item{\code{settings}}{Settings of the posterior sampling chain: burnin, n (number of samples collected),
space (iters between samples), cpiter (con param moves between iters)}

\item{\code{hdp}}{hdpState object after the final iteration}

\item{\code{lik}}{Likelihood of data given model at each iteration}

\item{\code{numcluster}}{Number of raw data clusters in each posterior sample}

\item{\code{cp_values}}{Matrix of concentration parameter values (one column for each parameter) in each posterior sample (rows).}

\item{\code{clust_categ_counts}}{List of matrices (one from each posterior sample)
counting the category-cluster data assignment across all DP nodes.
Number of rows is the number of categories (constant), and number of
columns is the number of clusters in that posterior sample (variable).}

\item{\code{clust_dp_counts}}{List of matrices (one from each posterior sample)
counting within-DP cluster assignment (aggregating across data categories).
Number of rows is the number of DPs (constant), and number of
columns is the number of clusters in that posterior sample (variable).}

\item{\code{numcomp}}{Number of global components extracted by \code{hdp_extract_components}
(not including component 0)}

\item{\code{prop.ex}}{(Average) proportion of dataset explained by the extracted components}

\item{\code{comp_cos_merge}}{\code{cos.merge} setting used by \code{hdp_extract_components}}

\item{\code{comp_categ_counts}}{List of matrices (one for each component)
counting the sample-category data assignment across all DP nodes.
Number of rows is the number of posterior samples, and number of
columns is the number of data categories.}

\item{\code{comp_dp_counts}}{List of matrices (one for each DP)
counting sample-component assignment (aggregating across data categories).
Number of rows is the number of posterior samples, and number of
columns is the number of components.}

\item{\code{comp_categ_distn}}{List with elements \code{mean} and \code{cred.int}, containing
matrices with the mean (and lower/upper 95\% credibility interval) distribution
over data categories for each component. Number of rows is the number of
components, and number of columns is the number of data categories. Rows sum to 1.}

\item{\code{comp_dp_distn}}{List with elements "mean" and "cred.int", containing
matrices with the mean (and lower/upper 95\% credibility interval) distribution
over components for each DP. Number of rows is the number of
DPs, and number of columns is the number of components. Rows sum to 1.}
}}

